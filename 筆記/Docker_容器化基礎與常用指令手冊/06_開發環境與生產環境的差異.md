## 第六章：開發環境與生產環境的差異

### 6.1 開發模式 (Development)

目前 `dog-project` 的 `docker-compose.yaml` 配置是專為開發設計的。其核心特徵在於 **「變動性」** 。

* **程式碼同步 (Hot Reload)**：
透過 `volumes: - ./backend:/app`，將宿主機的程式碼直接掛載進容器。這意味著容器內運行的其實是宿主機上的檔案。
* **除錯模式 (Debug Mode)**：
後端設定 `DEBUG=True`，當發生錯誤時，Django 會在瀏覽器直接顯示詳細的報錯資訊（包含程式碼片段與環境變數），方便除錯。
* **開發伺服器**：
* 後端使用 `python manage.py runserver`（單執行緒，效能低，不安全）。
* 前端使用 `npm run dev`（Vite 開發伺服器，負責即時編譯）。



### 6.2 生產模式 (Production)

當專案要部署到雲端伺服器（如 AWS, GCP）時，必須調整為生產模式。其核心特徵在於 **「不可變性 (Immutability)」**。

* **程式碼封裝 (No Volumes)**：
在生產環境中，**不應該**掛載原始碼。程式碼應該在 `docker build` 階段就完全複製進 Image 裡。
>*目的*：確保部署的版本與測試的版本完全一致，避免伺服器上的檔案被意外修改。


* **關閉除錯 (Security)**：
後端必須設定 `DEBUG=False`。否則，一旦報錯，駭客將能看到所有的程式碼結構與環境變數。
* **高效能伺服器**：
* **後端**：改用 **Gunicorn** 或 **Uvicorn** 作為 WSGI/ASGI 伺服器，配合 Nginx 處理反向代理。
* **前端**：執行 `npm run build` 打包出靜態檔案 (`dist/` 資料夾)，並由 **Nginx** 進行靜態資源託管 (Static Serving)。



### 6.3 Dockerfile 的多階段建置 (Multi-stage Builds)

為了縮小生產環境的 Image 體積，通常會使用多階段建置。

**以前端為例 (概念範例)：**

```dockerfile
# 階段一：建置環境 (Builder)
FROM node:18-alpine as builder
WORKDIR /app
COPY . .
RUN npm install && npm run build
# 此時產生了 /app/dist 資料夾

# 階段二：生產環境 (Runner)
FROM nginx:alpine
# 只複製階段一產生的 dist 資料夾，丟棄 node_modules (體積大幅縮小)
COPY --from=builder /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

### 6.4 安全性最佳實踐

在 `dog-project` 邁向生產環境時，需注意以下 Docker 安全原則：

1. **使用 `.dockerignore`**：
確保 `.env` (包含密鑰)、`.git`、`__pycache__`、`node_modules` 等檔案**不會**被複製進 Image。這不僅是為了縮小體積，更是為了避免敏感資訊外洩。
2. **非 Root 使用者執行**：
預設情況下，容器內的 Process 是以 root 權限執行。在生產環境中，建議在 Dockerfile 中建立並切換至低權限使用者 (User)，以降低容器被逃逸 (Container Breakout) 的風險。
